
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                 Temporal Logics
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Temporal Logics }

The syntax of the logics presented in this section involves different adaptations of existent formalisms. In both cases, we extend the grammars to include the required operators for formulas to be in negation normal form. We can put any formula $\varphi$ in negation normal form (\textit{nnf}) by exploiting equivalences and pushing negation inside, until it only occurs in front of atoms. 

Our semantics follow those defined by De Giacomo and Vardi \cite{giavar15a}. The adjustments made to fit our syntax into their formalisms are explained in detail throughout the next sections and present a unified format for the translation into alternating automata.

%%%%%%%%%%%%%%%%%% LTLf %%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection{Linear Temporal Logic on finite traces \LTLf}


Given a set of atoms $\A$, a \emph{temporal formula} $\varphi$ is defined by the grammar: 
\begin{align*}
    \varphi ::= &\; a \mid \neg a \mid \top \mid \bot \mid
        \varphi \wedge \varphi \mid 
        \varphi \vee \varphi \mid \Next \varphi \mid \wnext \; \varphi \mid 
        % \alwaysF \varphi \mid \eventuallyF \varphi \mid 
        \varphi \until \varphi \mid \varphi \release \varphi
\end{align*}

where we consider $a\in\A$ as atoms, Boolean constants $\top$ and $\bot$ and Boolean connectives $\vee$ and $\wedge$, well as the temporal connectives: $\Next$(next), $\wnext$(weak next), $\until$(until) and $\release$(release).

We adapt the syntax of \cite{cabsch19b} to work under the assumption that all formulas are in \nnf by
including the operators $\wnext$ and $\top$ as well the negation before atoms. 
Furthermore, we do not consider past operators as they impose implementation challenges. If such elements were required, any formula with past operators can be transformed into a (potentially more complex) formula using only future operators based on a separation property of temporal languages \cite{gabbay87a}.

Using the above grammar, we can derive other known operators such as:

\[
\begin{array}{rcll}
       \alwaysF \varphi  & \defeq & \bot \release \varphi             & \text{\emph{always}}\\
   \eventuallyF \varphi  & \defeq & \top \until \varphi               & \text{\emph{eventually}}\\
               \finally  & \defeq & \wnext \bot                   & \text{\emph{final}}
\end{array}
\]


As for the semantics, they are given in terms of finite traces, adapted from \cite{giavar15a} and \cite{cabsch19b}. 

\begin{definition}[Finite trace]
    A finite trace $\pi$ of length $\lambda$ over alphabet $\A$ is a sequence ${\langle \Pi_i \rangle}_{i=0}^{\lambda}$ of sets $\Pi_i \subseteq \A$, where $\Pi_i$ represents the propositional interpretation at time point $i$.
\end{definition}



\begin{definition}[Semantics]
    A trace $\pi$ of length $\lambda$ satisfies a temporal formula $\varphi$ at time point $i$, written $\pi,i \models\varphi$, according to the following inductive definition. 
    \begin{itemize}
      \item $\pi,i \not\models\bot$ \hspace{82px} 
      \item $\pi,i \models\top$ 
      
      \item $\pi,i\models a$ iff $\pi(i)\models a$ \hspace{30px} 
      \item $\pi,i\models \neg  a$ iff $\pi(i)\not\models a$
    
      \item $\pi,i \models\varphi_1 \wedge \varphi_2$ iff $\pi,i \models\varphi_1$ and $\pi,i \models\varphi_2$
      
      
      \item $\pi,i \models\Next \; \varphi$ iff $i<\lambda$ and $\pi,i+1 \models \varphi$
      
      \item $\pi,i \models\wnext \; \varphi$ iff $i<\lambda$ implies $\pi,i+1 \models \varphi$
      
      \item $\pi,i \models\alwaysF \; \varphi$ iff for all $j \in [\;i,\lambda]$, we have $\pi,j \models \varphi$
      
      \item $\pi,i \models\eventuallyF \; \varphi$ iff for some $j\in [\;i,\lambda]$, we have $\pi,j \models \varphi$
      
      \item $\pi,i \models\varphi_1 \until \varphi_2$ iff for some $j\in [\;i,\lambda]$, we have $\pi,j \models \varphi_2$ 
      \\\phantom{$\pi,i \models\varphi_1 \until \varphi_2$ iff for some $j\in [\;i,\lambda]$} 
      and $\pi,k \models \varphi_1$ for all $k\in [\;i,j)$
      
      \item $\pi,i \models\varphi_1 \release \varphi_2$ iff for all $j\in [\;i,\lambda]$, we have $\pi,j \models \varphi_2$ 
      \\\phantom{$\pi,i \models\varphi_1 \until \varphi_2$ iff for some $j\in [\;i,\lambda]$} 
        or $\pi,k \models \varphi_2$
      for some $k\in [\;i,j)$
    \end{itemize}
\end{definition}

\begin{definition}
    A formula $\varphi$ is satisfied by a trace $\pi$, written as $\pi\models\varphi$, iff $\pi,0\models\varphi$.
\end{definition}

% -------------- Example LTLf ------------
\begin{example}[$\LTLf$ formula]
    The formula $\varphi=(a\wedge b)\until c$ expresses the condition that both $a$ and $b$ will be true in every instant until $c$ becomes true. The trace $\pi_1=\{a,b,c\},\{a,b\},\{a,c\}$ satisfies the formula, whereas the trace $\pi_2=\{a,b,c\},\{a\},\{a,c\}$ does not, since $\pi_2,1 \not\models a\wedge b$ and also $\pi_2,1 \not\models c$.
\end{example}

%%%%%%%%%%%%%%%%%% LDLf %%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Linear Dynamic Logic on finite traces \LDLf}

We now introduce a temporal logic called $\LDLf$ \cite{giavar13a} which extends $\LTLf$ by including regular expressions as path expressions, increasing the expressive power of $\LDLf$ to that of Monadic Second Order logic over finite traces. 

In \LDLf, \emph{dynamic formulas} $\varphi$ and \emph{path expressions} $\rho$ are mutually defined by the pair of grammar rules:
\begin{align*}
  \varphi &::= a \mid \bot \mid \top \mid \; \dalways{\rho} \varphi \; \mid \; \deventually{\rho} \varphi \\
  \rho    &::=  \top \mid \varphi ? \mid \rho + \rho \mid \rho\mathrel{;}\rho \mid \rho^{\ast}
\end{align*}

where path expressions $\rho$ are formed by $\top$ interpreted as a step; the test construct $\varphi?$ which ensures formula $\varphi$ is satisfied in the current time point without performing a step; the choice between paths $\rho+\rho$; the composition of paths $\rho;\rho$ and the iteration using $\rho^\ast$. Dynamic formulas $\varphi$, on the other hand, are built from atoms $a\in\A$; Boolean constants $\top$ and $\bot$; connective $\dalways{\rho}\varphi$ expressing that from the current instant all executions satisfying $\rho$ are such that their last instant satisfies $\varphi$; and $\deventually{\rho}\varphi$ expressing that from the current instant there exists an execution satisfying $\rho$ are such that its last instant satisfies $\varphi$.

This syntax is similar to that of Dynamic Logic (\DL) \cite{hatiko00a}, but unlike in $\DL$ were a special alphabet is considered for atomic actions, we keep a single alphabet $\A$ and apply the test construct to its elements as a means to include atoms in path expressions. This adaptation can also be considered as a restriction on the syntax from \cite{giavar15a} where the only proposition allowed as an atomic path expression is the Boolean constant $\top$.   


Just like for $\LTLf$, the semantics of $\LDLf$ is given in terms of finite traces \cite{giavar15a}. We introduce the notation $\pi (i,j)$ to denote the segment of trace $\pi$ starting at the $i$-th time point and ending at the $j$-th time point. 

\begin{definition}[Semantics]
    A dynamic formula $\varphi$ is satisfied at time step $i$ of a trace $\pi$, written $\pi,i \models\varphi$, based on the parallel induction on formulas and path expressions described below:
\begin{itemize}
\item $\pi,i\models a$ iff $\pi(i)\models a$
\item $\pi,i \not\models\bot$
\item $\pi,i \models\top$ 
\item $\pi,i \models\dalways{\rho}\varphi$ iff for all $j\geq i$ such that $\pi(i,j)\in\mathcal{L}(\rho)$ then $\pi,j\models\varphi$
\item $\pi,i \models\deventually{\rho}\varphi$ iff exists $j\geq i$ such that $\pi(i,j)\in\mathcal{L}(\rho)$ and $\pi,j\models\varphi$
\end{itemize}
    where the relation $\pi (i,j) \in \mathcal{L}(\rho)$ is defined as follows:
\begin{itemize}
\item $\pi(i,j)\in\mathcal{L}(\stp)$ iff $j=i+1$ and $j\leq length(\pi)$
\item $\pi(i,j)\in\mathcal{L}(\varphi ?)$ iff $j=i$ and $\pi,j\models\varphi$
\item $\pi(i,j)\in\mathcal{L}(\rho_1 + \rho_2)$ iff $\pi(i,j)\in\mathcal{L}(\rho_1)$ or $\pi(i,j)\in\mathcal{L}(\rho_2)$
\item $\pi(i,j)\in\mathcal{L}(\rho_1 ; \rho_2)$ iff
for some $k\in [i, j]$, we have $\pi(i,k)\in\mathcal{L}(\rho_1)$ and $\pi(k,j)\in\mathcal{L}(\rho_2)$
\item $\pi(i,j)\in\mathcal{L}(\rho^{\ast})$ iff $i=j$ or $\pi(i,j)\in\mathcal{L}(\rho ; \rho^{\ast})$
\end{itemize}
\end{definition}


As we show below, the above language allows us to capture several derived operators defined in terms of the dynamic operators \deventually{\cdot} and \dalways{\cdot}.
\[
  \arraycolsep=2pt\def\arraystretch{1.3}
  \begin{array}{rclp{1pt}rcl}
    \varphi \wedge \psi & \defeq & \deventually{\varphi?} \psi          && \varphi \vee \psi & \defeq & \deventually{\varphi?+\psi?} \top
    \\
    \varphi \to \psi & \defeq & \dalways{\varphi?} \psi             && \neg \varphi & \defeq & \varphi \to \bot
    \\
    \finally & \defeq & [\top]\bot                               && 
    \Next \varphi & \defeq & \deventually{\top} \varphi 
    \\
    \wnext \varphi & \defeq & \dalways{\top} \varphi                && 
    \eventuallyF \varphi & \defeq & \deventually{\top^*} \varphi  
    \\
    \alwaysF \varphi & \defeq & \dalways{\top^*} \varphi            && 
    \varphi \until \psi & \defeq & \deventually{(\varphi?;\top)^*} \psi 
    \\
    \varphi \release \psi & \defeq & (\psi \until (\varphi \wedge \psi)) \vee \alwaysF \psi && \dalways{\psi}\varphi & \defeq & \dalways{\psi?;\top}\varphi
                                                
\end{array}
\]

% -------------- Example LDLf ------------

\begin{example}[$\LDLf$ formula]
    The dynamic formula $\varphi=\deventually{(a? ; \top ;b? ; \top)^*}c$ expresses the condition that there must be a path where zero or more times $a$ holds and in the following instant $b$ holds, when the repetitions defined by the star is completed then in the next step $c$ must hold. The trace $\pi_1=\{a\},\{b\},\{a\},\{b\},\{c\}$ satisfies the formula since $a$ followed by $b$ is repeated some amount of times (two in this case) and then $c$ holds. The trace $\pi_2=\{c\}$ also holds, since the path $(a? ; \top ;b? ; \top)$  can also be repeated zero times. On the other hand, the trace $\pi_3=\{a,b\},\{a\},\{a,c\}$ does not satisfy the formula, since $\pi_3,1 \not\models c$ and also $\pi_3(1,3) = \{a,b\},\{a\} \notin \mathcal{L}(a? ; \top ;b? ; \top)$.
\end{example}