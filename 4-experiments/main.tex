\section{Experiments  }

\subsection{Setup}

For the experiments, we evaluated our implementation using different temporal constraints and initial states on the the simplified $\asprilo$ domain. The presented results ran using $\clingo$ 5.4.0 on an Intel Xeon E5-2650v4 under Debian GNU/Linux 9, with a memory of 20 GB and a timeout of 20 min per instance.

Throughout the experiments, we use three temporal constraints to limit the movements of robots. These constraints make use of additional predicates, which are included as part of the planning encoding. The first constraint is shown in Listing 19 and it restricts robots to move vertically before horizontally (allowing pauses between movements). Such constraint corresponds to the temporal formula $\neg\; \mathit{move\_horizontally(robot(R))} \until (\alwaysF \;\neg \;\mathit{move\_vertically(robot(R)))}$.

\begin{center}
    \begin{lstlisting}[] 
:- not &tel{(~ move_horizontally(robot(R)) ) >? 
                (>* ~ move_vertically(robot(R))) },
    robot(R).
    \end{lstlisting}
\captionof{lstlisting}{Move vertically before horizontally in $\LTLf$ .}
\end{center}

We can also express this constraint in $\LDLf$ using the equivalent formula \\ $\deventually{ (\mathit{no\_move\_horizontally(robot(R))} ; \top)^\ast} \dalways{\top^\ast} \mathit{no\_move\_vertically(robot(R))}$. \\The integration of predicates \texttt{no\_move\_horizontally/1} and \texttt{no\_move\_vertically/1} into the encoding is necessary to account for the aforementioned restrictions on this logic.

\begin{center}
    \begin{lstlisting}[] 
:- not &del{ *( ? no_move_horizontally(robot(R)) ;; &true ) .>? 
             ( (* &true ) .>* no_move_vertically(robot(R)) )}, 
    robot(R).
    \end{lstlisting}
\captionof{lstlisting}{Move vertically before horizontally in $\LDLf$ .}
\end{center}

The constraint to enforce horizontal movements before vertical ones is defined analogously to Listing 19 and Listing 20. For the last constraint, we ensure that robots move only in one direction in the x axis (right or left) and in one direction in the y axis (up or down). 

\begin{center}
    \begin{lstlisting}[] 
:- not &tel{ (>* (~ move_right(robot(R)))) |  
             (>* (~ move_left(robot(R)))) }, 
    robot(R).

:- not &tel{ (>* (~ move_up(robot(R)))) |  
             (>* (~ move_down(robot(R)))) }, 
    robot(R).
    \end{lstlisting}
\captionof{lstlisting}{Never both directions in $\LTLf$.}
\end{center}

By applying the equivalences for each operator we can translate the first formula in Listing 20 to one on $\LDLf$, namely $\deventually{(\dalways{\top^\ast}~move\_right(robot(R)))? + (\dalways{\top^\ast}~move\_left(robot(R)))?}\top$. This formula, however, does not follow our restrictions given that the test construct is applied to a formula with the box operator. Therefore, this constraint required some adjustments to be written under our specification, yielding the encoding in Listing 22.


\begin{center}
    \begin{lstlisting}[] 
:- not &del{ *(&true ;; ? no_move_right(robot(R))) +
             *(&true ;; ? no_move_left(robot(R))) .>?
             (&true.>* &false) }, 
    robot(R).

:- not &del{ *(&true ;; ? no_move_up(robot(R))) +
            *(&true ;; ? no_move_down(robot(R))) .>?
            (&true.>* &false) }, 
robot(R).
    \end{lstlisting}
\captionof{lstlisting}{Never both directions in $\LDLf$.}
\end{center}

Regarding the planning instances, we consider warehouses defined by configurations varying in size and number of robots. In the presented results, we follow the naming format for $\asprilo$ instances, where name \textit{xN\_yM\_rO} refers to instances of grid size $N\times M$ with $O$ robots.  
We also explored two different types of arrangements of the warehouse. A \emph{structured} one, where the robots are always in the lower left corner (Figure 4), as well as a second one, called \emph{grid} where robots are scattered in the space and obstacles can be present (Figure 5). 
For each configuration, we contemplate five initial states differing on the position of the destinations, represented by the last two numbers of the instance name.


\begin{figure}
    \centering
\begin{subfigure}{.45\textwidth}
    \centering
    \includegraphics[scale=0.18]{img/g-asprilo-nc.png}
    \caption{Movement of robots without constraint.}
\end{subfigure}%
\hspace{10px}
\begin{subfigure}{.45\textwidth}
    \centering
    \includegraphics[scale=0.18]{img/g-asprilo.png}
    \caption{Applying constraint of never both directions.}
\end{subfigure}
\caption{Asprilo visualization for grid instance g-x5\_y5\_n20\_r5-05 with horizon 5, where cells in black represent obstacles.}
\end{figure}

\subsection{Results}


In the following results, we compare our implementation using automata from temporal and dynamic formulas against the encoding without these additional constraints, refereed to as `nc'. As baseline, we use a translation of the integrity constraints in $\LTLf$ to plain ASP trough $\TELf$, in the same way as in $\telingo$ \cite{cakamosc19a}. We use the name `asp' to refer to this last approach.

First, we present the most significant results encountered regarding the solving times of each method when searching for all the stable models of the program. In Figure 6, we can notice that, as expected, solving times are reduced drastically when applying a new integrity constraint to the program. In the case of no constraint, the solver reaches a timeout for all instances and constraints. Furthermore, the performance of the approach using $\LTLf$ is overall better than that for $\LDLf$. This behavior can be due to the different representation of states, either by numbers or predicates, between both methods. Moreover, it can be related to the differences of the translation of formulas. Overall, our baseline persist being considerably faster.



\begin{figure}[]
    \centering
    
    \input{plots/time-7-mean.tex}
    \caption{Average of solving and grounding times for all three constraint with horizon 7 when obtaining all models in $\clingo$. Unsatisfiable instances are marked with *.}
\end{figure}

A higher horizon was required for bigger instances to become satisfiable, however, increasing the horizon led mostly to timeouts. Thus, we used clingo to compute only one model in order to examine more details about the programs for such larger instances. In Figure 7, we show the size of the program w.r.t. the number of rules and bodies with horizon 20. This figure presents instances grouping all initial states of each configuration. The proportion of rules and bodies remains proportional throughout the experiment, indicating that while programs increased in size of the new encoding, this was done by the same amount of rules as bodies. 
% Therefore, there was no special increase in facts.
We can also notice a minimal increase in size of the program when using the translation to ASP, whereas the introduction of the automata encoding almost doubles the original size.

\begin{figure}[]
    \centering
    
    \input{plots/rules-bodies-mean.tex}
    \caption{Average number of rules and bodies for all three constraint with horizon 20 when obtaining one model. Instances are grouped by configuration. }
\end{figure}


Next, we decided to inspect the scalability of the implementation for both temporal and dynamic logic. This was done by increasing the horizon and asking only for the first model. The results are shown in Figure 8 and show a similar behavior between both models. Interestingly, the solving time for the dynamic formulas is only better on the instances with the configuration of $10\times 10$ and 20 robots.


\begin{figure}[]
    \centering
    
    \input{plots/scale-mean.tex}
    \caption{Average solving times for all three constraint with horizons 20 to 35, when obtaining one model. Instances are grouped by configuration. }
\end{figure}


For our last analysis, we examined the number of choices and conflicts found by the solver for each approach. This was done for instances using the grid configuration. Results on Table 3 correspond to the number of conflicts when computing all models with a horizon of 5. 
Unlike the rest of the analysis, we here show the results only for the constraint ensuring robots do not move in both directions (listings 21 and 22). 
As we can observe in Table 3, the numbers decreased in over one order of magnitude for all satisfiable instances. 
Particularly, in the case of instance $g-x5\_y5\_n20\_r5-05$ (Figure 5), where 5 obstacles are presented\footnote{The number of obstacles is calculated based on the name as follows: $O=X\times Y-N$}, we can see a drastical improvement. Some of the presented instances become unsatisfied when including the constraints, due to the presence of obstacles which can only be avoided by moving in both directions. Furthermore, the number of conflicts is reduced in half when using temporal instead of dynamic logic.
A similar evaluation was performed for the number of choices in the program (Table 4). Here we recognize the same type of reduction. Although, in this case, the difference of choices between both logics is not as evident. As final remarks on these results, we notice an improvement on the use of the automata approach against our baseline for the first two instances. However, this gain is not encountered in the rest of the experiments.






\begin{table}
\centering
\input{tables/grid-conflicts-status-5-never_both_direction.tex}
\caption{Number of conflicts with horizon 5 obtaining all models of instances in the grid configuration for constraint "never both directions". Results marked with * refer to unsatisfiable status. Instances in the first half of the table have 5 obstacle, whereas the ones in the bottom half have none.}
\end{table}


\begin{table}
\centering

    \input{tables/grid-choices-status-5-never_both_direction.tex}
    \caption{Number of choices with horizon 5 obtaining all models of instances in the grid configuration for constraint "never both directions". Results marked with * refer to unsatisfiable status. Instances in the first half of the table have 5 obstacle, whereas the ones in the bottom half have none.}
\end{table}