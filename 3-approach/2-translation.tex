\subsection{Automaton translation  }

Given the set of facts from the reification of a temporal formula, we now proceed to generate the equivalent automaton. First, we must single out all propositions used in the formula which will correspond to the alphabet $\A$. Propositions can be characterized by their corresponding identifier on the theory facts as it is done in the encoding below. 

\begin{center}
    \begin{lstlisting}[] 
pos_prop_id(ID) :- theory_function(ID,ID_O,ID_T),
                   theory_string(ID_O,P), 
                   not operator(P),
                   not reserved_words(P).

pos_prop_id(ID) :- theory_string(ID,P),
                   not operator(P), 
                   not reserved_words(P).

prop_id(ID) :- pos_prop_id(ID), 
               #count{1,ID_P: theory_function(ID_P, _, ID_T),
                              theory_tuple(ID_T,0..MAX,ID),
                              not pos_prop_id(ID_P)} > 0, 
               #max{D:theory_tuple(_,D,_)} = MAX.

used_id(ID) :- theory_string(ID,S), S != "last".
used_id(ID) :- theory_function(ID,IDS,_), 
               theory_string(IDS,S), S != "last".
last_id(MID+1) :- #max{ID:used_id(ID)} = MID.
theory_string(ID,"last") :- last_id(ID).

    \end{lstlisting}
    \captionof{lstlisting}{Encoding handling propositions}
\end{center}

The identifier used for a proposition is selected depending on whether the proposition comes from a nested predicate, such as $a(b)$, or one with arity 0 like $a$.
We use the identifier from $theory\_function$ in the case of predicates with arity grater than 0 (lines 1-4), corresponding to either functions or nested predicates (marked in blue on Figure 3).
On the other hand, for those with arity 0, we use the identifier from $theory\_string$ (lines 6-8). 
We exclude theory facts describing operators of our grammar and reserved words, saved in predicates \texttt{operator/1}\footnote{We use \texttt{p/i} to describe a predicate with name $p$ and arity $i$} and \texttt{reserved\_words/1}, respectively. 
Additionally, we remove terms which only appear as part of the arguments of other propositions (lines 10-14). 
This will allow us, for instance, to consider only $b(a)$ in our alphabet without considering $a$.
To achieve this, the rule uses two types of aggregates \cite{potasscoManual}, which are modeling constructs that let us from groups of selected items subject to conditions. 
In this case, aggregate \texttt{\#count} from line 11, will count the number of times a possible proposition, with id \texttt{ID}, appears in the arguments of another possible proposition with id \texttt{ID\_P}, and make sure this number is 0. 
In line 14 we use the aggregate \texttt{\#max} to find the largest arity, in order to limit the previous search.


Moreover, we manually include the special proposition $\mathit{last}$ required in our translation (lines 16-20). Predicate \texttt{used\_id/1} gathers all used identifiers in lines 16 and 17. Line 19 computes the next free identifier, while line 20 incorporates it as if it were part of the reified output.

% TODO id_map define, when it is final

The next step consists of defining the set of states and the transition function of the automaton. 
Different approaches were taken for each logic due to implementation restrictions. Let us now go into the details for each specific logic. 



\subsubsection{States and transitions for $\LTLf$}

As seen before, the translation from a temporal formula $\varphi$ into an alternating automaton defines the set of states using a special closure $cl(\varphi)$. 
In this definition, a special treatment is given to formulas $\varphi_1\release\varphi_2$ and $\varphi_1\until\varphi_2$. 
However, we can limit the closure to only the subformulas of $\varphi$, consequently reducing the set of states. 
This is achieved by unfolding the transitions of these two operators with the case analysis corresponding to the next and weak next operators respectively. 

Working only with the subformulas gives us the advantage of using the identifiers from the reified output as states. Such decision is based on the key observation that all subformulas are given a unique identifier appearing in the $theory\_function$ predicate, as it is illustrated in the AST in Figure 3. 


\begin{center}
    \begin{lstlisting}[] 
state(ID) :- theory_function(ID,ID_O,ID_T),
             theory_string(ID_O,P), 
             operator(P).

state(ID):- prop_id(ID).

initial_state(ID) :- theory_atom(ID_A,ID_O,ID_E),
                     theory_string(ID_O,"tel"),
                     theory_element(ID_E,ID_T,_),
                     theory_tuple(ID_T,0,ID).
    \end{lstlisting}
    \captionof{lstlisting}{Encoding defining states from temporal formulas}
\end{center}

Lines 1-3 collect all functions, representing subformulas, from the reified output using the operators of the grammar. Line 5 includes propositions, computed in Listing 4, as part of the states. Finally, line 7 defines the initial state of the automaton using special theory-specific facts. 

Regarding the transition function, both logics encode it base of the transition system with a predicate \texttt{delta/2}, composed by a state and an extended positive Boolean formula. Considered in these extended positive Boolean formulas is also the case analysis over the current interpretation. 
Such formulas are constructed with predicates: \texttt{pbf\_true/0} and \texttt{pbf\_false/0} for Boolean constants; \texttt{pbf\_and/2} and \texttt{pbf\_or/2} connecting two formulas; \texttt{pbf\_state/1} where the the argument is a state; and lastly \texttt{pbf\_if/3} used to represent the case analysis based on the propositional identifier as first argument. Listing 6 is a representative part of the encoding constructing the transition function for temporal formulas. The definitions for the remaining operators are analogous to the ones presented. 

\begin{center}
    \begin{lstlisting}[] 
% Proposition
delta(ID ,pbf_if(ID,pbf_true,pbf_false)) :- 
        prop_id(ID).

% True (False)
delta(ID ,pbf_true) :-
        theory_function(ID,ID_O,ID_T),
        theory_string(ID_O,"&"),
        theory_tuple(ID_T,0,ID_L),
        theory_string(ID_L,"true").

% Negation
delta(ID ,pbf_if(ID_L,pbf_false,pbf_true)) :- 
        theory_function(ID,ID_O,ID_T),
        theory_string(ID_O,"~"),
        theory_tuple(ID_T,0,ID_L).
        
% Next (Weak next)
delta(ID ,pbf_if(ID_LAST,pbf_false,pbf_state(ID_L))) :-
        theory_function(ID,ID_O,ID_T),
        theory_string(ID_O,">"),
        theory_tuple(ID_T,0,ID_L),
        last_id(ID_LAST).

% And (Or)
delta(ID ,pbf_and(PBF_L,PBF_R)) :-
        theory_function(ID,ID_O,ID_T),
        theory_string(ID_O,"&"),
        theory_tuple(ID_T,0,ID_L),
        theory_tuple(ID_T,1,ID_R),
        delta(ID_L,PBF_L),
        delta(ID_R,PBF_R).

% Until (Release)
delta(ID ,pbf_or(PBF_R,pbf_and(PBF_L,pbf_if(ID_LAST,pbf_false,pbf_state(ID))))):-
        theory_function(ID,ID_O,ID_T),
        theory_string(ID_O,">?"),
        theory_tuple(ID_T,0,ID_L),
        theory_tuple(ID_T,1,ID_R),
        delta(ID_L,PBF_L),
        delta(ID_R,PBF_R),
        last_id(ID_LAST).
\end{lstlisting}
\captionof{lstlisting}{Representative part of the encoding defining the transition function for temporal formulas}
\end{center}

\subsubsection{States and transitions for $\LDLf$}


Unlike for $\LTLf$, in the case of dynamic formulas we are forced to compute the closure of the formula in order to construct the set of states. During the construction of the states, we can't longer identify them with a number, as it is impossible to generate new identifiers for each formula in the closure using only ASP. Therefore, states will be identified in $\LDLf$ by a predicate. To achieve this we first map the ids from the reified linear format into a representation based on nested predicates, as shown in Listing 7\footnote{We include the negation to simplify syntax.}. 

\begin{center}
    \begin{lstlisting}[] 
% Proposition
map_id_to_predicate(ID,prop(ID)) :- 
        prop_id(ID).

% Top (Bottom)
map_id_to_predicate(ID,top) :-                                                        
        theory_function(ID,ID_O,ID_T), 
        theory_string(ID_O,"&"),
        theory_tuple(ID_T,0,ID_L),
        theory_string(ID_L,"true").

% Negation
map_id_to_predicate(ID,neg(FL)) :-                                                        
        theory_function(ID,ID_O,ID_T), 
        theory_string(ID_O,"~"),
        theory_tuple(ID_T,0,ID_L),
        map_id_to_predicate(ID_L,FL).

% Diamond (Box) (Box (Box))
map_id_to_predicate(ID,diamond(FL,FR)) :-
        theory_function(ID,ID_O,ID_T),
        theory_string(ID_O,".>?"),
        theory_tuple(ID_T,0,ID_L),
        theory_tuple(ID_T,1,ID_R),
        map_id_to_predicate(ID_L,FL), 
        map_id_to_predicate(ID_R,FR).

% Test Path (Star Path)
map_id_to_predicate(ID,test(FL)) :-                                                   
        theory_function(ID,ID_O,ID_T), 
        theory_string(ID_O,"?"),
        theory_tuple(ID_T,0,ID_L),
        map_id_to_predicate(ID_L,FL).

% Sequence Path (Choice Path)
map_id_to_predicate(ID,sequence(FL,FR)) :-                                                   
        theory_function(ID,ID_O,ID_T), 
        theory_string(ID_O,";;"),
        theory_tuple(ID_T,0,ID_L),
        theory_tuple(ID_T,1,ID_R),
        map_id_to_predicate(ID_L,FL), 
        map_id_to_predicate(ID_R,FR).
\end{lstlisting}
\captionof{lstlisting}{Encoding defining the mapping between ids and nested predicates for dynamic formulas}
\end{center}


Using the new representation, we construct the set of states based on the closure.
For this process, we use predicate \texttt{dynamic\_formula/1}, containing only the nested predicates for dynamic formulas saved in \texttt{map\_id\_to\_predicate/2}, while excluding the path expressions. The encoding is provided in Listing 8, where Line 1 includes all dynamic formulas in the closure, Line 3 includes the negation of propositions, lines 5 to 17 define the closure for the diamond operator (analogous the box operator), and finally line 19 defines the set of states derived from the closure. 

\begin{center}
    \begin{lstlisting}[] 
closure(F) :- dynamic_formula(F).

closure(neg(prop(ID))) :- closure(prop(ID)).

closure(diamond(X,Z)) :- 
        closure(diamond(choice(X,Y),Z)).

closure(diamond(Y,Z)) :- 
        closure(diamond(choice(X,Y),Z)).

closure(diamond(X,diamond(Y,Z))) :- 
        closure(diamond(sequence(X,Y),Z)).

closure(diamond(X,diamond(star(X),Z))) :- 
        closure(diamond(star(X),Z)).

closure(Z) :- closure(diamond(_,Z)).

state(F) :- closure(F).
\end{lstlisting}
\captionof{lstlisting}{Encoding defining closure and states for dynamic formulas}
\end{center}



% Thus, we must identify them in a different way, in this case by transforming the reified linear format into a representation based on nested predicates. 


It is also relevant to recall that negation was defined as syntactic sugar in our grammar and therefore can be fully eliminated. 
However, for simplicity, we include it in the implementation only before atoms. With the new representation of states, the definition of the transition function is straight-forward. Nonetheless, we show part of this encoding in Listing 9.


\begin{center}
    \begin{lstlisting}[] 
% Proposition
delta(prop(A),pbf_if(A,pbf_true,pbf_false)) :- 
        state(prop(A)).

% Negation
delta(neg(prop(A)),pbf_if(A,pbf_false,pbf_true)) :- 
        state(neg(prop(A))).

% Diamond Test (Box Test)
delta(diamond(test(F1),F2),pbf_and(BF1,BF2)) :- 
        state(diamond(test(F1),F2)), 
        delta(F1,BF1), 
        delta(F2,BF2).

% Diamond Step (Box Step)
delta(diamond(top,F),pbf_if(LAST,pbf_false,pbf_state(F))) :- 
        state(diamond(top,F)),
        last_id(LAST).

% Diamond Choice  (Box Choice)
delta(diamond(choice(P1,P2),F),pbf_or(BF1,BF2)) :- 
        state(diamond(choice(P1,P2),F)),
        delta(diamond(P1,F),BF1), 
        delta(diamond(P2,F),BF2).

% Diamond Sequence (Box Sequence)
delta(diamond(sequence(P1,P2),F),B) :- 
        state(diamond(sequence(P1,P2),F)),
        delta(diamond(P1,diamond(P2,F)),B).

% Diamond Star (Box Star)
delta(diamond(star(test(P)),F),B) :- 
        state(diamond(star(test(P)),F)), 
        delta(F,B).

is_test(test(P)):-state(diamond(star(test(P)),F)).
delta(diamond(star(P),F),pbf_or(BF,B)) :- 
        state(diamond(star(P),F)),
        delta(diamond(P,diamond(star(P),F)),B),
        delta(F,BF),
        not is_test(P).
\end{lstlisting}
\captionof{lstlisting}{Encoding defining transition function for $\LDLf$}
\end{center}


After calling $\clingo$ with the given encodings for each logic, we complete the translation process. The resulting declarative representation of the automaton, is a list of facts composed by predicates \texttt{state/1}, \texttt{initial\_state/1} and \texttt{delta/2}. Additional predicates \texttt{id\_prop/1} and \texttt{id\_last/1} are also saved, since they are needed to run traces by the automaton. The representation is unified between both logics, differing only in the way states are identified, thus making the rest of the implementation independent of the type of logic. 

\begin{example}[Automaton declarative representation]
        
        \begin{center}
                \begin{lstlisting}[] 
initial_state(8).
prop_id(3).
prop_id(6).
state(3).
state(6).
state(4).
state(7).
state(8).
last_id(9).
delta(3,pbf_if(3,pbf_true,pbf_false)).
delta(6,pbf_if(6,pbf_true,pbf_false)).
delta(4,pbf_if(9,pbf_false,pbf_state(3))).
delta(7,pbf_or(pbf_if(3,pbf_true,pbf_false),
        pbf_and(pbf_if(6,pbf_true,pbf_false),
        pbf_if(9,pbf_false,pbf_state(7))))).
delta(8,pbf_and(pbf_if(9,pbf_false,pbf_state(3)),
        pbf_or(pbf_if(3,pbf_true,pbf_false),
        pbf_and(pbf_if(6,pbf_true,pbf_false),
        pbf_if(9,pbf_false,pbf_state(7)))))).

                \end{lstlisting}
        \captionof{lstlisting}{Example of the automaton representation for the running example from Listing 2. The identifies of the states correspond to those from Listing 3.}
        \end{center}
\end{example}
