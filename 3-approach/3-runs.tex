\subsection{Accepted runs of an automaton  }

We now go ahead with the verification of traces using the automaton. Traces can be either randomly generated, explicitly defined as facts or computed as part of a planning problem, the last case is addressed in a following section. We describe traces using a predicate \texttt{in\_trace\_at(ID,T)} \footnote{We avoid the use of usual propositions \textit{holds} and \textit{occurs}, because from the point of view of the automaton there is no difference between actions and fluents. Furthermore, such predicates are likely to have already been used in the planning domain, causing inconsistencies.} stating that the proposition with id \textit{ID} is in the trace at time point $T$.

Further consideration was needed for the special proposition $\mathit{last}$. Like for most dynamic scenarios, we require a fixed horizon as part of the parameters for solving. Such horizon defines the length of all traces, therefore, determining the time step where the special proposition $\mathit{last}$ holds, encoded in the rule \texttt{in\_trace\_at(ID,horizon) :- last\_id(ID).}.

For the evaluation of traces, we construct runs as $S-$labeled trees. We introduce predicate \texttt{node\_run/3}, where the first argument is either a Boolean constant, represented by \texttt{true} and \texttt{false}, or \texttt{state\_id(ID)} mapping the node to its corresponding label: a state with id \texttt{ID}. The second argument is the level of the node, equivalent to the time point in the trace, and in the last argument is the nodes parent.

\begin{center}
    \begin{lstlisting}[] 
node_run(state_id(ID),0,root) :- initial_state(ID).

node_run_unfold(BD,T+1,node_run(state_id(ID),T,P)) :-  
        node_run(state_id(ID),T,P), 
        delta(ID, BD), T<=horizon.

node_run(state_id(ID),T,P) :- 
        node_run_unfold(pbf_state(ID),T,P).

node_run(true,T,P) :- 
        node_run_unfold(pbf_true,T,P).

node_run(false,T,P) :- 
        node_run_unfold(pbf_false,T,P).

node_run_unfold(B1,T,P) :- 
        node_run_unfold(pbf_and(B1,B2),T,P).

node_run_unfold(B2,T,P) :- 
        node_run_unfold(pbf_and(B1,B2),T,P).

1{node_run_unfold(B1,T,P); node_run_unfold(B2,T,P)}1 :- 
        node_run_unfold(pbf_or(B1,B2),T,P).

node_run_unfold(B1,T,P) :- 
        node_run_unfold(pbf_if(V,B1,B2),T,P), 
        in_trace_at(V,T-1).

node_run_unfold(B2,T,P) :- 
        node_run_unfold(pbf_if(V,B1,B2),T,P), 
        not in_trace_at(V,T-1).        
\end{lstlisting}
\captionof{lstlisting}{Encoding defining the runs of an automaton.}
\end{center}

The first line from Listing 11, creates the root node of the tree, with the initial state as label. Lines 3 to 5, based on the transition function, generate an auxiliary predicate \texttt{node\_run\_unfold/3} with a positive Boolean formula as first argument which requires to be unfolded. The rest of the encoding performs the unfolding of such formulas, where lines 7 to 14 correspond to the base cases and lines 16 to 20 unfold the conjunction creating two children. The rule from lines 22 and 23 uses a choice to select one possible run from a disjunction. Finally, lines 25 to 31 address the case analysis where the corresponding formula is selected in accordance with predicate \texttt{in\_trace\_at/2}. The acceptance condition is represented in the following encoding.

\begin{center}
    \begin{lstlisting}[] 
degree(node_run(B,T,P),A) :-  
        #count{1,B',T':node_run(B',T',node_run(B,T,P))}=A, 
        node_run(B,T,P).

accepting(node_run(state_id(ID),T,P)) :-  
        #count{1,B,T':accepting(node_run(B,T',node_run(state_id(ID),T,P)))}=A,
        A>=1,
        A==A',
        degree(node_run(state_id(ID),T,P),A'),
        node_run(state_id(ID),T,P).

accepting(node_run(true,T,P)) :- node_run(true,T,P).

:- not accepting(node_run(_,0,root)).

:- node_run(false,N,P).
    \end{lstlisting}
\captionof{lstlisting}{Encoding defining the acceptance condition of runs}
\end{center}

The first in rule in Listing 12 calculates the degree (number of children) of the nodes, which is used in the second rule to define the accepting nodes. We say a node is accepted if it hits the true transition (line 12) or if all its children are accepted (lines 5-10). The integrity constraint in line 14 ensures that the root node is accepting.  


Regarding the specification of traces, they can be explicitly defined by facts using the predicate \texttt{in\_trace\_at/2}. Moreover, the encoding can be trivially extended with a functionality to generate all possible traces accepted by the automaton. Such behavior is represented by adding a choice rule generating all traces, which is be filtered by the automaton.

\begin{center}
    \begin{lstlisting}[] 
{in_trace_at(ID,0..horizon)} :- prop_id(ID).

    \end{lstlisting}
\captionof{lstlisting}{Choice rule generating possible traces}
\end{center}

