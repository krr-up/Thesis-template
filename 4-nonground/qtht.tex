\subsection{QTHT}

\subsubsection{Foundations}

The building blocks of the syntax of our language will be that of
function-free first order languages, where we have a set of constant
symbols $C$, an infinite set of variables
$X=\{x_i \mid i\in \mathbb{N} \}$ and a set of predicate symbols $P$
with associated arity. Atoms are built using predicates, constants and
variables, like $p(t_1,\dots, t_n)$ where $p\in P$ is of arity $n$, and
$t_i \in X \cup C$ for $\rangecc{i}{1}{n}$ is a \emph{term}. A first
order temporal formula is then built from atoms using the same grammar
as for propositional temporal formulas, along with the additional
production rules:

$$
\varphi ::= \forall x \varphi(x) \mid \exists x \varphi(x)
$$

We denote the set of all such formulas as the language
$\mathcal{L_{C,P}}$, which we sometimes abbreviate as $\mathcal{L}$
when this does not lead to confusion.

Let $D$ be a non-empty set, called a \emph{domain}. We let $\A(D,P)$
stand for the set of ground atomic sentences constructable from $D$
and $P$. Furthermore, we define an interpretation $\sigma$ of $C$ and
$D$ as a function
$$
\sigma: C \cup D \rightarrow D
$$
such that $\sigma(d) = d$ for all $d \in D$.

\begin{definition}[TQHT-structure \cite{agcapevidi17a}]
  A THT $\mathcal{L}$ structure with static domains, or TQHT-structure
  for short, is defined as a tuple $\qthandt$, where for any
  $\kinlambda$ $H_k,T_k \subseteq \A(D,P)$., and $H_k \subseteq T_k$.

  We call a TQHT structure total iff $\bm{H}=\bm{T}$
\end{definition}

The satisfaction relation for TQHT structures is almost completely the
same as that the of THT satisfaction relation defined in section 2, if
one substitutes $\bm{M}=\qthandt$. They differ in the satisfaction
relation for atoms, and additionally TQHT satisfaction is also defined
for for first order quantifiers and equality. These are formalized
below, as stated in \cite{agcapevidi17a}.

\begin{description}
  \item $\bm{M},k \models p(t_1, \dots, t_n) \in \A(C \cup D,P)$ iff $p(\sigma(t_1), \dots, \sigma(t_n))\in H_k$
  \item $\bm{M},k \models t = s$ for any $t,s \in C \cup D$ iff $\sigma(t) = sigma(s)$
  \item $\qthandt \models \forall x \phi(x)$ iff $\qthandt \models \phi(d)$ for any $d \in D$ and for all $w \in \{\bm{H}, \bm{T}\}$ 
  \item $\bm{M} \models \exists k \phi(x)$ iff $\bm{M} \models \varphi(d)$ for some $d \in D$
\end{description}

The logic induced by the tautologies as per the satisfaction relation
above is called quantified temporal Here-and-There logic with static
domain, or QTHT for short.

Persistence can be proven to hold in TQHT as well.

\begin{proposition}[QTHT Persistence \cite{agcapevidi17a}]
For any formula $\varphi$, if $\qthandt \models \varphi$, then $qttandt \models \varphi$.
\end{proposition}

First order temporal equilibrium models can be defined in the usual way.

\begin{definition}[First order temporal equilibrium model/stable model \cite{agcapevidi17a}]
  A total TQHT structure $\qttandt$ is a (first order) temporal
  equilibrium model of a theory $\Gamma$ iff $\qttandt \models \Gamma$
  and there is no $\bm{H} < \bm{T}$ such that
  $\qthandt \models \Gamma$.
\end{definition}

We define a first order variant of a temporal rule and temporal program.

\begin{definition}[Universal temporal rule/temporal program] We call
  formulas of the form $\forall x_1, \dots, \forall x_n \varphi$,
  where $\varphi$ is a temporal rule, a \emph{universal temporal rule}. We
  call a set of such formulas a \emph{universal temporal program}.
\end{definition}

We should note that in the logic programming context, we usually
assume that we have a so-called Herbrand structure \cite{peaval06a},
in which we have $\dsigma = \langle C, id \rangle$, where $id$ is the
identity function, i.e. that the constants of the input program
constitute the domain, and that each constant is mapped to itself. We
do not make this assumption where not necessary in the following, and
state the results in their general form.

\subsubsection{Safety}

The usual non-temporal definition of safety requires that each
variable occurring in a rule also occur in a positive literal of the
body of the rule. This syntactic constraint is imposed to guarantee
that a program of such rules will be \emph{domain independent}, and
that it will not contain any \emph{unnamed individuals}
\cite{capeva09b}. Domain independence states that the answer sets of
the program do not change if they are ground using a superset of the
program's constants. This is important, as otherwise, adding a new
rule that one would expect to have no affect on the answer sets of the
program, can still change the answer sets simply by the virtue of
introducing a new constant symbol. \cite{agcapevidi17a} extended this
safety definition to the temporal setting by allowing atoms in the
scope of a singe $\Next$ to provide safety, and proved that this
extended definition satisfied domain independence, and ensured that
here are no unnamed individuals in the answer sets of a program. In
this section, we will relax the safety condition even further, and
prove that these desirable properties still hold, by retracing the
steps of the proof from \cite{agcapevidi17a}. In the following, the
term subformula is considered to be reflexive, i.e. $\varphi$ is a
subformula of $\varphi$.

\begin{definition}[Safety]
  Given a formula $\varphi$, we say that a subformula $\gamma$ of
  $\varphi$ is unsafe in $\varphi$, iff it is the operand of
  $\neg/\wprevious/\wnext$ or either operand of $\vee$ or if it the
  left operand of $\since/\until/\trigger/\release$ in $\varphi$.

  We say that an atomic subformula occurs in a safe position in a formula
  $\varphi$ iff it is a subformula of $\varphi$, and it is not the
  subformula of a subformula of $\varphi$ that is unsafe in B.

  Then, given a Utemporal rule
  $\psi=\forall x_1, \dots, x_n \alwaysF(B \rightarrow H)$, We say
  that an atomic subformula is in a safe position in $\psi$ iff it is
  a subformula of $B$, and it is not the subformula of a subformula of
  B that is unsafe in B.

  Finally, we say that a Utemporal rule $\psi$ is safe iff. all of it's variables are safe.
\end{definition}

Under this expanded definition of safety, the following program would
also be considered safe:

\begin{center}
    \begin{lstlisting}[numbers=none]
should_not_shoot(X)  :- since(not(loaded(X)),prev(shoot(X))).
    \end{lstlisting}
\end{center}

We will now embark on the path towards proving the two desirable
properties of the new safety definition.

\begin{lemma}\label{lemma1}
  Let $\varphi$ be a temporal formula without variables, and let
  $p_1,\dots,p_n$ be the atomic subformulas occurring in a safe
  position in $\psi$, if any. It follows that if
  $\qthandt,j \models F$, then for all $p_i \in \rangecc{i}{0}{n}$,
  there exists a $\kinlambda$, such that $\qthandt,k \models p_i$
\end{lemma}
\begin{proof}
The property can be shown to by structural induction on $\varphi$.
\end{proof}

\begin{lemma}\label{lemma2}
  Let $\varphi$ be a temporal formula without variables. Then, if
  $\qttandt \models \varphi$ and $\qttandt \not\models \varphi$, it
  follow that there is a $\kinlambda$ and an atomic subformula $p$ in
  $F$, such that $\qttandt \models p$ and
  $\qttandt \not\models \varphi$.
\end{lemma}
\begin{proof}
  The property can be shown to by structural induction on
  $\varphi$. The only inductive step that does not follow immediately
  is that of $\neg \varphi$. Note that in case if
  $\qttandt \models \neg \varphi$, then by persistence we must have
  $\qthandt \models \neg \varphi$, so the property holds.
\end{proof}

We call a variable assignment $\mu$ in $\dsigma$ a mapping from the
set of variables to $D$. If $\varphi$ has free variables, let
$\varphi^\mu$ be the formula obtained by replacing every free variable
$x$ by $\mu(x)$. Let $\bm{T}_{|C} \defeq \bm{T}\cap \sigma(C)$
\cite{agcapevidi17a}.

\begin{lemma}
  Let $\varphi=\alwaysF (B \rightarrow H)=\alwaysF \psi$ be a temporal rule, and
  $\mu$ a variable assignment in $\dsigma$. If $\varphi$ is safe, then
  $\qttandt,k \models \varphi^\mu$ implies
  $\qttcandt,k \models \varphi^\mu$
\end{lemma}
\begin{proof}
  In the following, let $M=\qttandt$, and $M_C=\qttcandt$.

  Suppose indirectly that $M,k \models \varphi^\mu$, but
  $M_C,k \not \models \varphi^\mu$. Then, there must be some
  $k\leq i$, such that $M,i \models \psi^\mu$ and
  $M_C,i \not \models \psi^\mu$, which must mean that
  $M_C,i \models B^\mu$ and $M_C,i \not \models H^\mu$. By
  persistence, we then have $M,i \models B^\mu$, which we must also have $M,i \models H^\mu$, as we know that $M,k \models \alwaysF(B^\mu \rightarrow H^\mu)$. Now, we have found that $M,i \models H^\mu$ and $M_C,i \not \models H^\mu$. By applying Lemma \ref{lemma2}, we derive that there is some atomic subformula $q$ occurring in $H$, and a $\rangeco{j}{0}{\infty}$, such that $M,j \models q^\mu$ and $M_C,j \not \models q^\mu$. Therefore, we must have a variable $x$ in $q$, with $\mu(x) \not \in \sigma(C)$. As $x$ is safe, there must be an occurrence of $x$ in an atomic formula $p$ in a safe position of $B$. Furthermore, as $\mu(x) \not \in \sigma(C)$, we also have $M_C,l \not \models p^\mu$ for any $\rangeco{l}{0}{\lambda}$. Having determined this fact, we can now apply the contraposition of Lemma \ref{lemma1} show that $M_C,i \not \models B^\mu$, a contradiction that concludes the proof.
\end{proof}

From here, we can follow the proof of Proposition 5 and Theorem 2 from \cite{agcapevidi17a} more
or less verbatim, to show the following result.

\begin{theorem}[No Unnamed Individuals]
  If $\varphi$ is a safe Utemporal rule, and $\qttandt$ is a temporal equilibrium
  model of $\varphi$, then $\bm{T}_{|C}=T$ and $T_i \subseteq \A(\sigma(C),P)$ for and $0 \leq i$.
\end{theorem}

Let $(D,\sigma)$ be a domain and $D'\subseteq D$ a finite subset. The
grounding over $D'$ of a sentence $\varphi$, is denoted as
$Gr_{D'}(\phi)$. The grounding assigns to each atom itself, expands
universal/existential quantification conjunctively/disjunctively over
each possible replacement of the quantified variable by a domain
value, and propagates through all other connectives
\cite{agcapevidi17a}. 

The following result, stating domain independence, can also be proved
by applying Lemma 1 and Lemma 2 to reproduce Lemma 2 from
\cite{agcapevidi17a}, from which we can follow along the proof steps
to derive the result under our expanded definition of programs and
safety.

\begin{theorem}
Let $\varphi$ be a safe Utemporal rule. Suppose we expand the language $\mathcal{L}$ by considering a set of constants $C \subseteq C'$. A total QTHT model $\qttandt$ is a temporal equilibrium model of $Gr_{C'}(\varphi)$ iff it is a temporal equilibrium model of $Gr_{C'}(\varphi)$.
\end{theorem}

\subsubsection{Grounding}

Obtaining a ground instantiation of a universal temporal program is, as demonstrated at the
end of the previous section, is not as straightforward as one might
hope, as the grounding procedure of gringo is not QTHT model
preserving due to the simplifications it applies. We will therefore
instead construct a much simpler positive normal temporal program, and
retrieve the ground instances of our original program from there.

Formally, given a universal temporal rule
$r=\forall x_1 \dots x_n \alwaysF(B \rightarrow H)$, let $p_1, p_n$ be
the atomic subformulas occurring in a safe position in $B$, and
$h_1, \dots h_m$ the atomic subformulas occurring in H. We then
define the set of transformed rules:

\begin{equation*}
r^{\prime}=\{ \forall x_1, \dots \forall x_n 
\alwaysF(\bigwedge_{j=1}^{n}p_j \rightarrow h_i) \mid \rangecc{i}{1}{l} )\}
\end{equation*}
and $\Gamma^{\prime}$ the set of all transformed rules. Then, the
following result can be proven.

\begin{proposition}
Let $\qttandt$ be an equilibrium model of $\Gamma$, and $\langle \dsigma, \bm{J},\bm{J} \rangle$ the unique equilibrium model of $\Gamma^{\prime}$. Then, $\bm{T} \subseteq \bm{J}$.
\end{proposition}

This proposition can be used to derive a superset of the original
program's ground atoms, and then having derived these atoms,
substitute their terms to derive a ground instantiation. When
substituting ground atoms into the original program, care must be
taken to perform a join operation all predicates with shared
variables. 

Instead of performing this join ourselves, as in \cite{agcapevidi17a},
we use gringo for this purpose, and instead enhance our original
program $\Gamma$ with external statements similar to the form of
$r^{\prime}$, which will ensure that all the ground atoms of
$\Gamma^{\prime}$ are substituted into the program. For each rule
$r^{\prime}$ as above we generate an external statements, as described in the next subsection.
